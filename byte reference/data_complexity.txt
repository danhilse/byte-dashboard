⏺ Honestly? It's not that complex. Here's the real scope:

  What Clerk gives you for free:
  - Auth UI (sign in, sign up, forgot password)
  - Session management
  - User management dashboard
  - JWT tokens
  - OAuth if you want it later

  What you actually need to build:
  Feature: Tenant association
  Complexity: Low
  Why: Clerk webhook → create user record with tenant_id
  ────────────────────────────────────────
  Feature: Contacts CRUD
  Complexity: Low
  Why: Standard table + forms
  ────────────────────────────────────────
  Feature: Applications CRUD
  Complexity: Low
  Why: Standard table + forms
  ────────────────────────────────────────
  Feature: Tasks CRUD
  Complexity: Low
  Why: Standard table + forms
  ────────────────────────────────────────
  Feature: Stage advancement
  Complexity: Low
  Why: ~50 lines of logic
  ────────────────────────────────────────
  Feature: Dashboard stats
  Complexity: Low
  Why: A few COUNT queries
  ────────────────────────────────────────
  Feature: Role-based access
  Complexity: Medium
  Why: Clerk has roles, just check them
  The entire "workflow engine" is this:

  async function completeTask(taskId: string) {
    const task = await db.tasks.update({
      where: { id: taskId },
      data: { status: 'completed', completed_at: new Date()
   }
    });

    // Get next stage
    const nextStage = await db.stages.findFirst({
      where: {
        position_type: task.application.position_type,
        stage_order: { gt: currentStageOrder }
      },
      orderBy: { stage_order: 'asc' }
    });

    if (nextStage) {
      // Create next task
      await db.tasks.create({
        data: {
          application_id: task.application_id,
          title: nextStage.name,
          stage: nextStage.name,
          assigned_to: nextStage.default_assignee,
          status: 'pending'
        }
      });

      // Update application
      await db.applications.update({
        where: { id: task.application_id },
        data: { current_stage: nextStage.name }
      });
    } else {
      // No more stages - application complete
      await db.applications.update({
        where: { id: task.application_id },
        data: { status: 'hired' } // or whatever final
  status
      });
    }
  }

  That's it. That's the "workflow engine."

  Tech stack suggestion:

  Frontend: Next.js (you already know React)
  Auth: Clerk
  Database: Postgres on Supabase or Neon
  ORM: Prisma (or Drizzle)
  UI: shadcn/ui (already using it)
  Forms: External (Typeform/Tally) → webhook
  Hosting: Vercel

  Realistic timeline for one developer:
  ┌───────┬───────────────────────────────────┬───────────┐
  │ Phase │               What                │   Time    │
  ├───────┼───────────────────────────────────┼───────────┤
  │ 1     │ Schema + Clerk setup + basic CRUD │ 1-2 weeks │
  ├───────┼───────────────────────────────────┼───────────┤
  │ 2     │ Applications + stage logic        │ 1 week    │
  ├───────┼───────────────────────────────────┼───────────┤
  │ 3     │ Tasks + assignment                │ 1 week    │
  ├───────┼───────────────────────────────────┼───────────┤
  │ 4     │ Dashboard + polish                │ 1 week    │
  └───────┴───────────────────────────────────┴───────────┘
  4-6 weeks to a working MVP. Not months.

  What made the current system complex:
  - Visual workflow builder (unnecessary)
  - Form builder (unnecessary)
  - Trigger system (unnecessary)
  - Over-abstracted data model (workflow_instances, etc.)
  - Trying to make everything infinitely configurable

  What you should hardcode (at least for MVP):
  - Stage definitions (just seed data, edit in DB directly)
  - Email templates (code, not a template builder)
  - Role permissions (code, not a permissions matrix UI)

  You can always add configurability later. Ship first.

  Honest assessment: This is a weekend project that got
  enterprise-brain'd into a mess. Strip it back and it's
  straightforward CRUD with one bit of interesting logic
  (stage advancement).

❯ what's the deal with this? how can it be so
  outrageously out of control

⏺ A few things probably happened:

  1. AI-assisted "vibe coding"

  Someone (or multiple people) used AI to generate features
   without understanding the whole. Each feature makes
  sense in isolation:
  - "Build me a workflow system" → gets workflow tables
  - "Add triggers for automation" → gets trigger tables
  - "We need a form builder" → gets form tables

  But no one asked: "Wait, do these fit together? Do we
  even need all this?"

  2. Enterprise cosplay

  The system is built like it's Salesforce serving 10,000
  companies. But it's an ATS for sheriff's offices. You
  don't need:
  - A visual node-based workflow builder
  - A drag-and-drop form builder
  - A trigger/condition/action automation engine
  - Multi-level permission matrices

  You need: contacts, applications, tasks, users. That's
  it.

  3. Premature abstraction

  Instead of:
  application has tasks

  They built:
  workflow defines workflow_steps
  application creates workflow_instance from workflow
  workflow_instance creates workflow_instance_tasks from
  workflow_steps
  triggers watch workflow_instance_tasks and fire actions

  Four layers of indirection for something that could be
  one.

  4. No one said "no"

  Every feature request got implemented instead of
  questioned:
  - "Can we have custom forms?" → Build a form builder
  (instead of: use Typeform)
  - "Can we have conditional logic?" → Build a trigger
  system (instead of: write an if statement)
  - "Can we visualize workflows?" → Build a ReactFlow
  canvas (instead of: a numbered list)

  5. Copy-paste architecture

  Someone probably looked at tools like:
  - Zapier (triggers/actions)
  - Monday.com (workflow builder)
  - Typeform (form builder)

  And thought "we need all of that" instead of "what do we
  actually need?"

  The tell-tale signs I saw:
  What I Found: Workflow Builder doesn't affect execution
  What It Means: Built for demos, not function
  ────────────────────────────────────────
  What I Found: Triggers are separate from steps
  What It Means: Two systems that should be one
  ────────────────────────────────────────
  What I Found: Form Builder half-finished
  What It Means: Started, realized it's hard, abandoned
  ────────────────────────────────────────
  What I Found: "Export to Builder" button
  What It Means: Trying to bridge two systems that
  shouldn't
     both exist
  ────────────────────────────────────────
  What I Found: My Work = Tasks + Applications mashed
    together
  What It Means: No clear product thinking
  The root cause:

  No one with authority said: "What's the simplest thing
  that works?"

  Instead it was: "What if we need X later?" and "Wouldn't
  it be cool if..." and "The AI can build it so why not?"

  The answer to "why not" is: because now you have 15
  tables, 50 components, and a system no one fully
  understands.