  The Core Problem:
  The current system has too many interconnected tables
  because they built features in isolation. Workflows,
  tasks, applications, triggers, form submissions - all
  separate systems that awkwardly reference each other.

  Simpler Mental Model:

  Contact (person)
      └── Application (contact applying for a position)
              └── Tasks (things to do for this application)

  That's it. Everything else is configuration or metadata.

  ---
  Proposed Tables:

  -- CORE ENTITIES

  tenants (
    id, name, settings_json, created_at
  )

  users (
    id, tenant_id, email, name, role
  )

  contacts (
    id, tenant_id,
    first_name, last_name, email, phone,
    address_json,        -- {street, city, state, zip}
    custom_fields_json,  -- tenant-specific fields
    created_at
  )

  applications (
    id, tenant_id, contact_id,
    position_type,       -- "deputy_sheriff",
  "corrections", etc. (or FK to positions table)
    status,              -- "open", "in_progress", "hired",
   "rejected", "withdrawn"
    current_stage,       -- "application_review",
  "background_check", "interview", etc.
    submitted_at,
    metadata_json        -- source, notes, etc.
  )

  tasks (
    id, tenant_id, application_id,  -- nullable for
  standalone tasks
    title, description,
    task_type,           -- "workflow_step" | "manual" |
  "reminder"
    stage,               -- links to application stage if
  workflow task
    status,              -- "pending", "in_progress",
  "completed", "skipped"
    assigned_to,         -- user_id
    due_date,
    completed_at,
    created_at
  )

  -- CONFIGURATION (not runtime data)

  stages (
    id, tenant_id,
    position_type,       -- which position this stage
  belongs to
    name,                -- "Background Check"
    stage_order,
    default_assignee,    -- role or user
    default_days_to_complete,
    instructions         -- what to do at this stage
  )

  ---
  Key Simplifications:
  Current System: workflows + workflow_steps +
    workflow_instances +
    workflow_instance_tasks
  Simplified: stages (config) + tasks (runtime)
  ────────────────────────────────────────
  Current System: applications + workflow_instances
  Simplified: Just applications with a current_stage
  ────────────────────────────────────────
  Current System: Triggers as separate system
  Simplified: Just code that runs when task status changes
  ────────────────────────────────────────
  Current System: Form Builder + Form Submissions
  Simplified: External form tool → webhook → creates
  contact
     + application
  ---
  How it works:

  1. Admin setup: Define stages for each position type
    - Deputy Sheriff: Review → Background → Physical →
  Interview → Final
    - Corrections: Review → Background → Interview
  2. New application comes in:
  INSERT INTO applications (contact_id, position_type,
  status, current_stage)
  VALUES (123, 'deputy_sheriff', 'in_progress',
  'application_review');

  -- Auto-create first task
  INSERT INTO tasks (application_id, title, stage, status,
  assigned_to)
  SELECT app.id, s.name, s.name, 'pending',
  s.default_assignee
  FROM stages s WHERE s.position_type = 'deputy_sheriff'
  AND s.stage_order = 1;
  3. Task completed → advance stage:
  -- Simple function, not a complex trigger system
  UPDATE applications SET current_stage =
  'background_check' WHERE id = 123;

  -- Create next task
  INSERT INTO tasks (...) SELECT ... FROM stages WHERE
  stage_order = 2;
  4. Manual tasks: Same tasks table, just application_id
  optional and task_type = 'manual'

  ---
  What you DON'T need:

  - workflow_instances - The application IS the instance
  - workflow_task_triggers - Just write the logic in code
  - form_templates / form_submissions - Use
  Typeform/Formstack + webhook
  - workflow_builder_documents - Visual builder is
  unnecessary
  - Separate workflow_steps from runtime tasks - One tasks
  table handles both

  ---
  The JSON fields:

  Using _json columns (JSONB in Postgres) for:
  - custom_fields_json on contacts - Each tenant has
  different fields
  - address_json - Structured but rarely queried
  - metadata_json on applications - Flexible storage for
  notes, source, etc.

  This avoids the EAV (entity-attribute-value) anti-pattern
   while staying flexible.

  ---
  Summary:
  Tables Needed: tenants
  Purpose: Multi-tenancy
  ────────────────────────────────────────
  Tables Needed: users
  Purpose: Staff accounts
  ────────────────────────────────────────
  Tables Needed: contacts
  Purpose: Applicants
  ────────────────────────────────────────
  Tables Needed: applications
  Purpose: Contact + position + status
  ────────────────────────────────────────
  Tables Needed: tasks
  Purpose: All work items (workflow + manual)
  ────────────────────────────────────────
  Tables Needed: stages
  Purpose: Config: what stages exist per position
  6 tables instead of 15+. The relationships are clear:
  - Tenant has many users, contacts, applications
  - Contact has many applications
  - Application has many tasks
  - Stages define what tasks get auto-created